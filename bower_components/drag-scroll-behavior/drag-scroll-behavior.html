<link rel="import" href="../polymer/polymer-element.html">

<dom-module id="drag-scroll-behavior">
  <script>
    /**
     * Allowing scrolling to happen when you are dra
     * @extends Polymer.Element
     */
    class DragScrollBehavior extends Polymer.Element {
      static get is() {
        return 'drag-scroll-behavior';
      }

      static get properties() {
        return {
          scrollElement: {
            type: HTMLElement
          },
          dragScrollTargetHeight: {
            type: Number,
            value: 20
          },
          targetDisplay: {
            type: String,
            value: 'none'
          },
          /* how many pixels per frame, smaller => smoother & slower. larger => jumpy & faster */
          frameSize: {
            type: Number,
            value: 5
          },
          /* miliseconds per frame, smaller => faster scroll */
          msPerFrame : {
            type: Number,
            value: 25
          },
          topTargetOffsetTop: {
            type: Number,
            computed: '_getTargetPosition(targetDisplay, "top", scrollElement.offsetTop)'
          },
          bottomTargetOffsetTop: {
            type: Number,
            computed: '_getTargetPosition(targetDisplay, "bottom", scrollElement.offsetTop, scrollElement.offsetHeight, dragScrollTargetHeight)'
          },
          targetWidth: {
            type: Number,
            computed: '_getTargetWidth(targetDisplay, scrollElement.offsetWidth)'
          },
          scrollTargetColor: {
            type: String,
            value: 'transparent'
          }
        };
      }

      constructor() {
        super();
      }

      connectedCallback() {
        super.connectedCallback();
        this._observer = new Polymer.FlattenedNodesObserver(this, (info) => {
          this.scrollElement = this.querySelector('[slot="scroll-target"]');
        });
        this.addEventListener('dragover', this.handleDragOver);
        this.addEventListener('drop', this.handleDrop);
        this.addEventListener('mousemove', this.hideTargets);
        this.topTarget = this.shadowRoot.querySelector('.drag-scroll-target-top');
        this.bottomTarget = this.shadowRoot.querySelector('.drag-scroll-target-bottom');
        this.boundDragOverTopTarget = this.handleDragOverTopTarget.bind(this);
        this.boundDragOverBottomTarget = this.handleDragOverBottomTarget.bind(this);
        this.boundHideTargets = this.hideTargets.bind(this)
        this.topTarget.addEventListener('dragover', this.boundDragOverTopTarget);
        this.bottomTarget.addEventListener('dragover', this.boundDragOverBottomTarget);
        this.topTarget.addEventListener('mouseover', this.boundHideTargets);
        this.bottomTarget.addEventListener('mouseover', this.boundHideTargets);
      }

      disconnectedCallback() {
        super.disconnectedCallback();
        this._observer.disconnect();
        this.removeEventListener('dragover', this.handleDragOver);
        this.removeEventListener('drop', this.handleDrop);
        this.removeEventListener('mousemove', this.hideTargets);
        this.topTarget.removeEventListener('dragover', this.boundDragOverTopTarget);
        this.bottomTarget.removeEventListener('dragover', this.boundDragOverBottomTarget);
        this.topTarget.removeEventListener('mouseover', this.boundHideTargets);
        this.bottomTarget.removeEventListener('mouseover', this.boundHideTargets);
      }

      handleDragOver(e) {
        e.preventDefault();
        /* if top or bottom target is the actual target of dragged over, do nothing */
        if(e.composedPath()[0] === this.topTarget || e.composedPath()[0] === this.bottomTarget) {
          return;
        }
        /* if dragging over the top of scroll element and scroll element is already scrolled to the top OR
        if dragging over the bottom of scroll element and scroll element is already scrolled to the bottom
        do NOT show target */
        let layerY = e.layerY;
        if((layerY <= this.dragScrollTargetHeight && this.atTop(this.scrollElement)) || 
          (layerY >= this.scrollElement.offsetHeight - this.dragScrollTargetHeight && this.atBottom(this.scrollElement))) {
          this.targetDisplay = 'none';  
        } else {
          this.targetDisplay = 'block';
        }
      }

      handleDrop(e) {
        e.preventDefault();
        this.targetDisplay = 'none';
      }

      handleDragOverTopTarget(e) {
        if(this.scrollElement) {
          if(!this.atTop(this.scrollElement)) {
            this.scroll(-1);
            this.debouncedScrollEnd();
          } else {
            this.targetDisplay = 'none';
          }
        }
      }

      handleDragOverBottomTarget(e) {
        if(this.scrollElement) {
          if(!this.atBottom(this.scrollElement)) {
            this.scroll(1);
            this.debouncedScrollEnd();
          } else {
            this.targetDisplay = 'none';
          }
        }
      }

      hideTargets(e) {
        if(this.targetDisplay === 'block') {
          this.targetDisplay = 'none';
        }
      }

      debouncedScrollEnd(direction) {
        this.scrollDebouncer = Polymer.Debouncer.debounce(
          this.scrollDebouncer,
          Polymer.Async.timeOut.after('100'),
          this.scrollStop.bind(this)
        );
      }

      scroll(direction) {
        if(!this.scroller) {
          this.scroller = setInterval(()=>{
            this.scrollElement.scroll({
              top: this.scrollElement.scrollTop + this.frameSize * direction
            });
          }, this.msPerFrame);
        }
      }

      scrollStop() {
        clearInterval(this.scroller);
        this.scroller = null;
      }

      atTop(ele) {
        return ele.scrollTop === 0;
      }

      atBottom(ele) {
        return ele.scrollTop === ele.scrollHeight - ele.offsetHeight
      }

      _getTargetPosition(displayTarget, target, offsetTop, elementHeight, targetHeight) {
        if(displayTarget === 'none') return;
        offsetTop = offsetTop || 0;
        switch(target) {
          case 'top':
            return offsetTop;
          case 'bottom':
            return offsetTop + elementHeight - targetHeight;
        }
      }

      _getTargetWidth(displayTarget, width) {
        if(displayTarget) {
          return width;
        }
      }

      static get template() {
        return `
          <style>
            ${this.styleTemplate}
          </style>
          ${this.contentTemplate}
        `;
      }

      static get contentTemplate() {
        return `
          <div class="drag-scroll-target drag-scroll-target-top" style="
            height:[[dragScrollTargetHeight]]px;
            width: [[targetWidth]]px;
            top: [[topTargetOffsetTop]]px;
            display:[[targetDisplay]];
            background-color:[[scrollTargetColor]];
          "></div>
            <slot name='scroll-target'></slot>
          <div class="drag-scroll-target drag-scroll-target-bottom" style="
            height:[[dragScrollTargetHeight]]px;
            width: [[targetWidth]]px;
            top: [[bottomTargetOffsetTop]]px;
            display:[[targetDisplay]];
            background-color:[[scrollTargetColor]];
          "></div>
        `;
      }

      static get styleTemplate() {
        return `
          .drag-scroll-target {
            position: absolute;
            width: 100%;
            z-index: 9999;
          }
        `;
      }

    }

    customElements.define(DragScrollBehavior.is, DragScrollBehavior);

  </script>
</dom-module>
